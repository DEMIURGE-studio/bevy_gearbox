# `bevy_gearbox`

A Bevy plugin for managing entity states with support for hierarchical state machines.

## Why Use This?

States are components. bevy_gearbox integrates seemlessly with the bevy ecs and query systems. 

State changes are handled by observers, meaning you'll never have a character that is both `Idle` and `Dead`.

Perfect for game entities that need complex state management:
- **Characters** with abilities that can interrupt normal behavior
- **AI systems** with layered decision-making
- **Interactive objects** with multiple operational modes

## Quick Example

```rust
use bevy::prelude::*;
use bevy_gearbox::prelude::*;

#[derive(Component)]
struct Player;

#[derive(Component, Clone, Debug, Default)]
struct IdleState;

#[derive(Component, Clone, Debug)]
struct RunningState { speed: f32 }

#[derive(Component, Clone, Debug)]
struct JumpingState;

// Define the state machine. Think of this as defining a set of 
// mutually exclusive components. Exclusivity is maintained with
// observers. 
state_machine!(Player;
    IdleState,     // First state must implement Default
    RunningState,
    JumpingState
);

fn movement_system(
    mut commands: Commands,
    keyboard: Res<ButtonInput<KeyCode>>,
    players: Query<Entity, With<Player>>,
) {
    for player in &players {
        if keyboard.just_pressed(KeyCode::Space) {
            commands.entity(player).transition(JumpingState);
        } else if keyboard.pressed(KeyCode::KeyW) {
            commands.entity(player).transition(RunningState { speed: 10.0 });
        } else {
            commands.entity(player).transition(IdleState);
        }
    }
}
```

## Core Concepts

### State Machine Definition (generated by `state_machine!()`)

1. **Owner Component**: A Bevy component that identifies the state machine
2. **State Components**: Components representing individual states (first state must implement `Default`)
3. **`state_machine!` Macro**: Connects the owner to its possible states and generates:
   - A `<OwnerName>StateEnum` to track current state
   - A `<OwnerName>Plugin` with necessary systems

### State Transitions

Use the `StateTransitionCommandsExt` trait:
```rust
commands.entity(entity).transition(NewState);
```

The generated systems handle removing old state components and adding new ones automatically.

### Hierarchical State Machines

For advanced use cases, `bevy_gearbox` supports parent-child state machine relationships using special states:

- `RestingState`: Default inactive state for child state machines (supports "blockers")
- `WorkingState`: Active state when controlled by parent
- `InChildSMState(Entity)`: Parent state when delegating to child
- `FinishedChildSMState(Entity)`: Parent state when child completes
- `FizzledState`: Child state when parent exits prematurely

## Setup

1. **Add to your project:**
```bash
cargo add bevy_gearbox
```

2. **Add plugins to your app:**
```rust
use bevy::prelude::*;
use bevy_gearbox::GearboxPlugin;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(GearboxPlugin)
        .add_plugins(PlayerPlugin)  // Your generated plugin
        // ... other setup
        .run();
}
```

3. **Spawn entities:**
```rust
// Starts in IdleState automatically
commands.spawn(Player);
```

## Querying States

```rust
// Query by state component
fn idle_system(idle_players: Query<Entity, With<IdleState>>) { }

// Query by state enum
fn current_state_system(
    players: Query<&PlayerStateEnum, With<Player>>
) {
    for state in &players {
        match state {
            PlayerStateEnum::IdleState => { /* ... */ }
            PlayerStateEnum::RunningState => { /* ... */ }
            PlayerStateEnum::JumpingState => { /* ... */ }
        }
    }
}
```

## Advanced Features

- **Hierarchical State Machines**: Parent state machines can delegate control to child state machines
- **State Blocking**: Prevent transitions based on conditions (e.g., cooldowns, resource requirements)
- **Automatic State Management**: Handle complex parent-child state transitions automatically

---

## TODO

- Add comprehensive HSM examples (character abilities, AI behavior trees)
- Add state blocking examples (cooldowns, resource management)
- Add complex nested state machine example