/// Demonstrates basic use of the HSM feature. We define a character state machine with
/// a free move state, resting state, and dead state.
/// 
/// We also define an ability state machine with a resting state, working state, and fizzled state.
/// 
/// The character state machine is a parent of the ability state machine.
///
/// On giving an input, the character will transition to the child ability state machine.
/// When the ability is finished, the character will transition back to the free move state.
/// 
/// Note: You must manually transition the character back to the free move state, as well as 
/// any other transitions. Transitions are handled by observers, so you don't need to worry about
/// invalid states.
use bevy::prelude::*;
use bevy_gearbox::prelude::*;

#[derive(Component, Reflect)]
struct Character {
    name: String,
}

// Define a custom state for free movement
#[derive(Component, Clone, Debug, Default)]
struct FreeMoveState;

// Define a dead state
#[derive(Component, Clone, Debug)]
struct DeadState;

// Use the state machine macro to generate the state machine for Character
state_machine!(Character; 
    FreeMoveState,
    RestingState,
    InChildSMState,
    FinishedChildSMState,
    DeadState,
);

#[derive(Component, Reflect)]
struct Ability {
    name: String,
    duration: f32,
}

// Use the state machine macro for abilities
state_machine!(Ability;
    RestingState,
    WorkingState,
    FizzledState,
);

fn setup(mut commands: Commands) {
    info!("Setting up character state machine example");
    
    // Spawn a character
    let character = commands.spawn((
        Character { name: "Hero".to_string() },
    )).id();
    
    // Spawn an ability as a child of the character
    let ability = commands.spawn((
        Ability { 
            name: "Fireball".to_string(),
            duration: 2.0,
        },
    )).id();
    
    // Set up the parent-child relationship
    commands.entity(ability).set_parent(character);
    
    info!("Character and ability spawned");
}

fn cast_ability_system(
    mut commands: Commands,
    character_query: Query<Entity, (With<Character>, With<FreeMoveState>)>,
    ability_query: Query<Entity, (With<Ability>, With<RestingState>)>,
    keyboard: Res<ButtonInput<KeyCode>>,
) {
    if keyboard.just_pressed(KeyCode::Space) {
        for character_entity in character_query.iter() {
            // Find abilities that are children of this character
            for ability_entity in ability_query.iter() {
                info!("Character attempting to cast ability");
                
                // Transition character to child state (ability)
                commands.entity(character_entity).transition(InChildSMState(ability_entity));
                break;
            }
        }
    }
}

fn ability_progress_system(
    mut commands: Commands,
    mut ability_query: Query<(Entity, &mut Ability), With<WorkingState>>,
    time: Res<Time>,
) {
    for (ability_entity, mut ability) in ability_query.iter_mut() {
        ability.duration -= time.delta_secs();
        
        if ability.duration <= 0.0 {
            info!("Ability {} completed", ability.name);
            // Reset duration for next cast
            ability.duration = 2.0;
            // Transition back to RestingState to return control to parent
            commands.entity(ability_entity).transition(RestingState::new());
        }
    }
}

// System to transition character back to FreeMoveState when ability finishes
fn handle_finished_ability_system(
    mut commands: Commands,
    character_query: Query<Entity, (With<Character>, With<FinishedChildSMState>)>,
) {
    for character_entity in character_query.iter() {
        info!("Character ability finished, returning to free movement");
        commands.entity(character_entity).transition(FreeMoveState);
    }
}

fn character_state_logger(
    character_query: Query<&CharacterStateEnum, (With<Character>, Changed<CharacterStateEnum>)>,
) {
    for state in character_query.iter() {
        info!("Character state changed to: {:?}", state);
    }
}

fn ability_state_logger(
    ability_query: Query<&AbilityStateEnum, (With<Ability>, Changed<AbilityStateEnum>)>,
) {
    for state in ability_query.iter() {
        info!("Ability state changed to: {:?}", state);
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(GearboxPlugin)
        .add_plugins(CharacterPlugin) // Generated by the macro
        .add_plugins(AbilityPlugin)   // Generated by the macro
        .register_type::<Character>()
        .register_type::<Ability>()
        .add_systems(Startup, setup)
        .add_systems(Update, (
            cast_ability_system,
            ability_progress_system,
            handle_finished_ability_system,
            character_state_logger,
            ability_state_logger,
        ))
        .run();
} 